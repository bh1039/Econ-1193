<h1><center>Jonah, Garrett, and Ben Project 1</center></h1> (This cell is markdown)

(new cell)

Note to self: re add in some comments about functions (per assignment criteria)    (this is a markdown cell)

(new cell)

import numpy as np
import pandas as pd
import requests
import json
from matplotlib import pyplot as plt

%run APIkeys.py
key = os.environ['BLS_API_key']

(new cell)

# Building the basket list
prefix = 'CUUR'
#since Pittsburgh does not have updated data, we use Middle Atlantic Region to represent it (0120)
area = ['0120', 'S12A', 'S11A']
item = ['SAF1','SAR','SEHF','SAH','SAH2']

basketCPI = ['CUUR0000SA0']
for i in item:
    for a in area:
        basketCPI.append(prefix+a+i)

#gasoline not purchased in Pittsburgh
basketCPI.append('CUURS12ASETB01')
basketCPI.append('CUURS11ASETB01')

#using city average for missing data
basketCPI.append('CUUR0000SERA04')
basketCPI.append('CUUR0000SSEA011')
basketCPI.append('CUUR0000SEAA')
basketCPI.append('CUUR0000SEGE')
(new cell)
basketCPI

(new cell)

def multiSeries(varList,myKey,first='2018',last='2023'):
    # Input: varList = a list of strings containing the series names
    # Input: myKey =  a string containing your BLS API key
    # Output: new_df = a data frame containing the data collected
    
    base_url = 'https://api.bls.gov/publicAPI/v2/timeseries/data/'  #this will not change
    headers = {'Content-type': 'application/json'}  #This will not changed !

    parameters = {
        "seriesid":varList,
        "startyear":first, 
        "endyear":last,
        "catalog":True, 
        "calculations":False, 
        "annualaverage":False,
        "aspects":False,
        "registrationkey": myKey 
     }

    data = json.dumps(parameters) #this converts the Python dictionary into a JSON format
    
    p = requests.post(base_url, data=data, headers=headers)
    json_data = json.loads(p.text)
    
    if p.status_code != 200:
        # Handle error (e.g., print an error message or raise an exception)
        print(f"Error fetching data: {p.status_code}")
        return None
    
    n = len(varList) #number of series requested
    
    new_df = pd.DataFrame(columns=['year', 'period'])
    for item in range(n):
        l = len(json_data['Results']['series'][item]['data']) #length of the list
        if l == 0:
            print('Series ',varList[item],' does not exist')
        else:
            
            print('Series ',varList[item],' exists with ',l,' observations')
            d = json_data['Results']['series'][item]['data']
            current_df = pd.DataFrame(data=d)
            current_df = current_df[['year','period','value']].astype({'value': 'float64'})
            current_df = current_df.rename(columns = {'value':varList[item]}) 
            
            new_df = new_df.merge(current_df, on = ['year','period'],how='outer')
    
    return new_df

(new cell)

df = multiSeries(varList = basketCPI,myKey=key,first='2018',last='2023')

(new cell)

NOTE: Make a table here (or somewhere else) to show weights)    (this is a markdown cell)

(new cell)

df = df.rename(columns = {'CUUR0000SA0':'CPI_U'})
df.head(10)
(new cell)
df.sort_values(by=['year','period'],inplace=True,ascending=False)
(new cell)
bimonthly_vars = ['CUURS11ASAF1','CUURS11ASAR','CUURS11ASAH','CUURS11ASAH2']

def bimonthly2monthly(myData, ser):
    import pandas as pd
    import math
    
    n = len(myData[ser[0]]) 

    for col in ser:
        for i in range(1,n-1):

            if pd.isna(myData[col].iat[i]): #the value in place i is NaN
                myData[col].iat[i] = math.sqrt(myData[col].iat[i-1]*myData[col].iat[i+1]) #replace NaN with a geometric avg of i-1 and i+1

            if pd.isna(myData[col].iat[0]): #the value in the first place is NaN
                myData[col].iat[0] = myData[col].iat[1]*(myData[col].iat[1]/myData[col].iat[2]) #assume the same growth rate from 2 to 1 to be from 1 to 0

            if pd.isna(myData[col].iat[n-1]): #the value in the last place is NaN
                myData[col].iat[n-1] = myData[col].iat[n-2]*(myData[col].iat[n-2]/myData[col].iat[n-3]) #assume the same growth rate from n-2 to n-3 to be n-2 to n-1

    return myData

df = bimonthly2monthly(myData=df, ser=bimonthly_vars)

df.head()

(new cell)

missing_values = df.isnull().sum()
missing_values

(new cell)

#adding a row of zeros
nrows, ncols = df.shape
df["myCPI"] = np.zeros(nrows)

df.head()









